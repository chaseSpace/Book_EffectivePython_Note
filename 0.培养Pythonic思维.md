### 章节主题：培养 Pythonic 思维

- [1.查询自己使用的Python版本](#1查询自己使用的Python版本)
- [2.遵循PEP8风格指南](#2遵循PEP8风格指南)
- [3.了解bytes与str的区别](#3了解bytes与str的区别)
- [4.用支持插值的f-string取代C风格的格式字符串与str.format方法](#4用支持插值的f-string取代C风格的格式字符串与strformat方法)
- [5,用辅助函数取代复杂的表达式](#5用辅助函数取代复杂的表达式)
- [6.将数据结构直接拆分到多个变量里，不要专门通过下标访问](#6将数据结构直接拆分到多个变量里，不要专门通过下标访问)
- [7.尽量用enumerate取代range](#7尽量用enumerate取代range)
- [8.用zip函数同时遍历两个迭代器](#8用zip函数同时遍历两个迭代器)
- [9.不要在for与while循环后面写else块](#9不要在for与while循环后面写else块)
- [10.用赋值表达式减少重复代码](#10用赋值表达式减少重复代码)

### 章节描述

Pythonic 风格不是一套严格规范，而是众多Python开发者使用这门语言过程中逐渐形成的习惯，它的主题是直观、简洁且容易看懂（在Python解释器界面输入import this，可以查看The Zen Of Python）。

你也可以把Pythonic风格理解为一套最佳的使用Python的编程方式。


### 1.查询自己使用的Python版本

关于Python版本的几个信息这里说明一下：
- 最后一个稳定的Python2版本是v2.7.17，Python2在2020年1月1日正式退场，意味着这一刻所有的bug修复、安全补丁以及特性向后移植都会停止
- 深度依赖Python 2代码库的开发者可以考虑2to3（Python预装工具）与six（社区包）这样的工具过渡到Python3
- 本书大部分范例遵循 v3.7语法规范，v3.7发布于2018年6月
- 少部分范例采用v3.8语法规范，v3.8发布于2019年10月

要想查看某个操作系统中使用的python版本是什么，在系统CLI（命令行提示符）中输入`python --version`即可查看
```shell
lei@WilldeMacBook-Pro Book_EffectivePython_Note % python3 --version
Python 3.9.6
```
这里因为笔者使用的是mac book pro 14，所以已经没有预装有python2，`python`的命令快捷方式也没有了，但大部分linux系统是保留的。

通过在系统CLI中输入`python`再按tab键查看系统中有哪些python开头的命令快捷方式。下面使用内置的sys模块查看版本信息：
```shell
lei@WilldeMacBook-Pro Book_EffectivePython_Note % python3          
Python 3.9.6 (default, Sep 26 2022, 11:37:49) 
[Clang 14.0.0 (clang-1400.0.29.202)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> print(sys.version_info)
sys.version_info(major=3, minor=9, micro=6, releaselevel='final', serial=0)
>>> dir(sys.version_info)
['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'major', 'micro', 'minor', 'n_fields', 'n_sequence_fields', 'n_unnamed_fields', 'releaselevel', 'serial']
>>> print(sys.version_info.major,sys.version_info.minor,sys.version_info.micro)
3 9 6
>>> print(sys.version)
3.9.6 (default, Sep 26 2022, 11:37:49) 
[Clang 14.0.0 (clang-1400.0.29.202)]
```

### 2.遵循PEP8风格指南
 [PEP8][1] 是Python增强提案 #8，是一份针对Python 代码格式而编订的风格指南。遵循PEP8有助于团队协作和更高效的编码以及修复工作。

细则较多，此处省略。笔者建议直接使用流行的支持Python的编辑器来编写Python代码，然后使用其提供的格式化快捷键来美化代码格式。但是，为了心中有数，仍然建议先大致阅读一遍PEP8内容。

#### Pylint(https://www.pylint.org)
是一款流行的Python源码静态分析工具，可以自动检查代码是否符合PEP8风格指南，以及程序中的许多常见错误。很多IDE都包含这样的linting工具或支持类似插件。

笔者注：这里推荐文章 [pycharm配置autopep8和pylint](https://www.jianshu.com/p/aa9da0111a65) ，其他jetbrain家的IDE应当也是适用此法的。

### 3.了解bytes与str的区别
Python有bytes和str两种类型可以表示字符序列。bytes实例包含的是原始二进制数据，即8位无符号值（按ASCII编码显示），如下：
```shell
>>> a=b'h\x65llo'    // 65是ASCII表中字母e的十六进制字符
>>> print(list(a))
[104, 101, 108, 108, 111]  // 101是ASCII表中字母e的十进制字符
>>> print(a)
b'hello'
```
str实例包含的是Unicode码点，码点与某种语言（如中文、英文等）中的某个文本对应，如下：
```shell
>>> a='a\u897f吧'
>>> print(list(a))
['a', '西', '吧']
>>> print(a)
a西吧
```
Unicode码点虽然直接与具体语言文本关联，但打印出来的字符还会使用某个字符编码方案（默认是UTF8）进行解码，否则也不会看到`\u897f`显示为`西`，如果使用其他不支持显示中文的字符编码，
则会显示为特殊字符，如下：
```shell
>>> a='a\u897f吧'
>>> a.encode('utf8').decode('latin1')  // 需要先将str编码为bytes再使用其他字符编码进行解码为str
'aè¥¿å\x90§'
```

#### 3.1 二者之间的转换
bytes与str之间的转换，bytes调用decode得到str，反过来则是encode。需要注意的是，一旦开始转换，就要涉及到编码方案指定，当然可以使用默认的UTF8（但并不总是）：
```shell
>>> a=b'h\x65llo'
>>> a.decode()   // to str
'hello'
>>> a.decode().encode()  // to bytes
b'hello'
```

#### 3.2 二者使用说明
注意，bytes是二进制序列，无法再编码，意味着它是携带了一种字符编码方案的，而str就比较灵活，因为它包含的实际是Unicode码点。

所以在程序中，我们最好把字符的编解码放在最外层来做，在核心层使用str传输和计算。这样可以让程序接受多种字符编码（如Latin-1、Shift JIS、Big5）。

#### 3.3 二者不可混合使用
bytes和str它们各自之间可以使用 `+ < > ==` 操作符，但bytes和str混合就不可。自然，即使是表示相同字符的bytes和str也不会**相等**。
```shell
>>> b'a'+'b'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't concat str to bytes
>>> b'a'>'b'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '>' not supported between instances of 'bytes' and 'str'
>>> b'a'=='a'
False
```

在格式化的时候也是如此，如果格式字符是bytes类型，那么不能用str实例替换其中的`%s`，因为Python不知道这个str实例应该按照什么方案编码（str要转换为bytes需要选择一种字符编码）。
但如果是反过来，就可以，但情况可能跟你想的不同。
```shell
>>> b'red %s' % 'blue'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: %b requires a bytes-like object, or an object that implements __bytes__, not 'str'
>>> 'red %s' % b'blue'
"red b'blue'"  // 这里实际上替换的是 b'blue' 的 __repr__()
```

所以最好的办法是不要混用。

#### 3.4 使用二进制模式操作文件句柄
比如是写文件，如下代码：
```shell
>>> with open('data.bin', 'w') as f: f.write(b'\xf1')
... 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: write() argument must be str, not bytes
```
句柄默认使用文本模式写数据，如果要以bytes模式操作句柄，则需要将模式改为 `wb` 。

```shell
>>> with open('data.bin', 'wb') as f: f.write(b'\xf1')
... 
1   // 写入成功返回1
```

现在来读这个文件，因为刚写入的是一个随意的二进制数据，可以确定它无法使用操作系统默认的编码解码，所以下面的写法会报错：
```shell
>>> with open('data.bin', 'r') as f: f.read()
... 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/codecs.py", line 322, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 0: unexpected end of data
```
这里发现系统以utf-8编码进行解码但失败了。为什么会发生解码行为？因为我们以默认的文本模式打开句柄，读操作自然需要将二进制数据解码为str进行显示。
解码若不指定编码方案，则使用系统默认。通过下面的方式可以查看系统默认编码：
```shell
>>> import locale; print(locale.getpreferredencoding());
UTF-8
```


所以这里有两种办法，第一种是将模式改为`rb`，第二种是若你确定文件内容适用某种编码方案，则可以手动指定编码方案，如下：
```shell
>>> with open('data.bin', 'r', encoding='latin1') as f: f.read()
... 
'ñ'
```

---

[1]:[https://peps.python.org/pep-0008]