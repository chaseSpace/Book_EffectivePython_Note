## 第二章：列表与字典

- [1. 学会对序列做切片](#1-学会对序列做切片)
- [2. 不要在切片里同时指定起止下标与步长](#2-不要在切片里同时指定起止下标与步长)
- [3. 通过带星号的unpacking操作来捕获多个元素，不要用切片](#3-通过带星号的unpacking操作来捕获多个元素不要用切片)
- [4. 用sort方法的key参数来表示复杂的排序逻辑](#4-用sort方法的key参数来表示复杂的排序逻辑)
- [5. 不要过分依赖给字典添加条目时所用的顺序](#5-不要过分依赖给字典添加条目时所用的顺序)
- [6. 用get处理键不在字典中的情况，不要使用in与KeyError](#6-用get处理键不在字典中的情况不要使用in与KeyError)
- [7. 用defaultdict处理内部状态缺失的元素，而不要用setdefault](#7-用defaultdict处理内部状态缺失的元素而不要用setdefault)
- [8. 学会利用__missing__构造依赖键的默认值](#8-学会利用__missing__构造依赖键的默认值)

### 1. 学会对序列做切片
Python中的list, str, bytes等只要实现了`__getitem__`和`__setitem__`的类型都支持切片。切片语法支持对序列做范围读取以及范围修改，如下：
```python
_list = [1,2,3,4,5]
# 范围读取
assert _list[1:3] == [2,3]

# 范围修改
_list[1:3] = [12,13]
assert _list == [1,12,13,4,5]
# - 当进行范围修改时，允许等号两边的元素个数不同，效果是会影响变量的长度
_list[1:3] = [12,13,14]
assert _list == [1,12,13,14,4,5]
_list[1:3] = 12
assert _list == [1,12,14,4,5]
```
注意，当从序列中范围读取元素时，生成的是新序列，是一次深拷贝。

### 2. 不要在切片里同时指定起止下标与步长
除了基本的切片用法，Python还支持带有stride（步进）的切片用法，比如`somelist[start:end:stride]`。
stride的用法允许我们从序列中每stride个元素选取一个元素，这种用法很容易从序列中奇数和偶数位置上的元素取出来，如下：
```python
_list = [1,2,3,4,5]
assert _list[::2] == [1,3,5] # 所有奇数位置的元素
assert _list[1::2] == [2,4] # 所有偶数位置的元素

# 此外，指定stride为负数，可以反转序列
assert _list[::-1] == [5,4,3,2,1]
# str也可以
assert "寿司"[::-1] == "司寿"
# 更复杂的用法
print(_list[1::-1])
print(_list[1:3:-1])
# ...
```
如代码所示，更复杂的用法在我们看来太过晦涩，降低了代码可读性，所以并不推荐在代码中使用带有stride的切片用法，若实在要用，则最好使用正数作为stride，
且范围参数要留空，如`somelist[::1]`，若必须指定范围，则最好分开两步进行：
```python
_list = [1,2,3,4,5]
x = _list[::2] # [1,3,5]
x1 = x[1:-1] # [3]
```

### 3. 通过带星号的unpacking操作来捕获多个元素，不要用切片
拆分数据结构并把数据赋值给变量时，可以使用带星号的表达式，将结构中无法与普通变量相匹配的内容捕获到一份列表里。
```python
number=[1,3,5,7,9]
e1, e2, *other=number
```
若使用下标，则需要多行代码，可读性差，复杂度相比略高。

使用星号unpacking需要注意的几点：
- 元素不足时，`*other`是一个空list，但普通变量必须分配到元素，否则报错。
- 除了list，还可以应用到dict、generator、tuple
- 单次分配时，不能同时出现多个星号变量
- 星号变量可以出现在首位、中间、末尾等任何位置，但至少要搭配一个普通变量使用
- 对迭代器使用时，星号变量总是会形成一个列表实例，所以要注意迭代器元素过多导致大内存占用的问题